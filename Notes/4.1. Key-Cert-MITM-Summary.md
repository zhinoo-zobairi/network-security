Okay, I want to send B a message, and I am A. I use B's public key to encrypt the message I want to send them, and they can decrypt it with their own private key. *(Of course, this is RSA, and in reality, RSA is way too slow for encrypting entire communications. What actually happens is: I encrypt a random "premaster secret" with B's public key, B decrypts it with their private key, and then both of us derive the same symmetric session key from this premaster secret. All the actual data communication uses this symmetric key with something fast like AES, not RSA.)*

Now, the problem here is, I don't really know if this public key actually belongs to B that I'm going to talk to. So I need a certificate authority to vouch for B. The certificate authority has a public key, which is my trust anchor. B sends me their certificate, and I use the CA's public key to verify the certificate's signature - not encryption in the sense of confidentiality, only verification. The signature is supposed to be done by the certificate authority's private key. So I verify the signature, make sure it's from the certificate authority, and see that inside the certificate it states that the public key really belongs to the receiver, in this case B, that I'm going to talk to. Great, so now I can continue the process - I use this public key that I was vouched for to encrypt messages I'm going to send to B *(or in reality, to encrypt that premaster secret for the key exchange)*, and B can decrypt them.

But there's still a problem here. Despite the certificate authority being in the loop, someone in the middle could have sent me the certificate, not B themselves. The certificate authority won't send me the certificate anyway - the receiver sends it. So it may be the case that B didn't really send me the certificate, but a man in the middle sent it to me. That means, even though I have a legitimate certificate, it may not have been sent by the server. So what happens is: the man in the middle sends me the certificate from the server, I use the public key of the certificate authority (the trust anchor) to verify the certificate, it's legitimate, and then I believe that I'm really talking to the server - although I'm not, I'm talking to a man in the middle. 

I do everything as if I were talking to the receiver itself. I encrypt with the public key of the receiver and send it back, and it reaches the man in the middle instead. The man in the middle, of course, cannot decrypt my message, but they can forward it to the real server, change it, block it, see timing patterns - basically do stuff with it, which is not what we want. 

So what's my approach to prevent this? I use challenge-response. *(In reality, there are two approaches for challenge-response: 1) Decryption-based - I encrypt a random nonce with B's public key and send it as a challenge. B must decrypt it with their private key and send the nonce back. Only someone with the private key can decrypt and return the correct value. 2) Signature-based - I send a random challenge in plaintext, and B must sign it with their private key. I verify the signature with B's public key. Only someone with the private key can create a valid signature. Both prove possession of the private key, just through different operations. In TLS, it's typically signature-based where the server signs the handshake messages including random nonces from both sides.)*

What does that mean? I send a challenge - either an encrypted random nonce that B must decrypt and return, or a plaintext challenge that B must sign and return. Either way, B needs their private key to respond correctly. That's when I can really verify that I'm talking to the receiver in real time and not someone else in the middle. If the man in the middle intercepts my challenge, they can't respond correctly because they don't have B's private key - they can't decrypt the encrypted nonce, and they can't create a valid signature. This proves I'm talking to the real server at this moment, not a man in the middle who's just forwarding B's legitimate certificate.
